# Java Concurrency in Practice

## 线程安全性

在并发编程中，由于不恰当的执行时序而出现的不正确的结果，称为**竞态条件**。

最常见的竞态条件类型就是“先检查后执行”，即通过一个可能失效的观测结果来决定下一步的动作。“先检查后执行”的一种常见情况就是延迟初始化（确保只被初始化一次）。

当在不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

Java提供了一种内置的锁机制来支持原子性：同步代码块。以关键字`synchronized`修饰。

同步代码块包括两部分：

1. 作为锁的对象引用
2. 作为由这个锁保护的代码块

某个线程请求一个由其他线程持有的锁时，会阻塞。而由于内置的锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，这个请求就会成功。

**重入**意味着锁的操作粒度是线程，而不是调用。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

## 对象的共享

同步除了可以确保原子性外，还有一个重要的方面：**内存可见性**。我们希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说是可见的，否则读到的可能是一个失效值。

Java提供了一种稍弱的同步机制：`volatile`变量。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型变量时总会返回最新写入的值。
不过在访问volatile变量时不会执行加锁操作，是一种比synchronized关键字更轻量级的同步机制。

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

如果仅在单线程内访问数据，就不需要同步，这也被称为**线程封闭**。

- Ad-hoc线程封闭：维护线程封闭的职责完全由程序实现来承担。
- 栈封闭：只能通过局部变量才能访问对象。局部变量位于执行线程的栈中，其他线程无法访问这个栈。但需要确保被引用的对象不会逸出。
- ThreadLocal类：为每个使用该变量的线程都存有一份独立的副本。可以将`TheadLoacal<T>`看做`Map<Thread, T>`，其中保存了特定于该线程的值。
