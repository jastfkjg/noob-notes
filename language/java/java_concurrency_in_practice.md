# Java Concurrency in Practice

## 线程安全性

在并发编程中，由于不恰当的执行时序而出现的不正确的结果，称为**竞态条件**。

最常见的竞态条件类型就是“先检查后执行”，即通过一个可能失效的观测结果来决定下一步的动作。“先检查后执行”的一种常见情况就是延迟初始化（确保只被初始化一次）。

当在不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

Java提供了一种内置的锁机制来支持原子性：同步代码块。以关键字`synchronized`修饰。

同步代码块包括两部分：

1. 作为锁的对象引用
2. 作为由这个锁保护的代码块

某个线程请求一个由其他线程持有的锁时，会阻塞。而由于内置的锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，这个请求就会成功。

**重入**意味着锁的操作粒度是线程，而不是调用。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

## 对象的共享

同步除了可以确保原子性外，还有一个重要的方面：**内存可见性**。我们希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说是可见的，否则读到的可能是一个失效值。

Java提供了一种稍弱的同步机制：`volatile`变量。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型变量时总会返回最新写入的值。
不过在访问volatile变量时不会执行加锁操作，是一种比synchronized关键字更轻量级的同步机制。

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

如果仅在单线程内访问数据，就不需要同步，这也被称为**线程封闭**。

- Ad-hoc线程封闭：维护线程封闭的职责完全由程序实现来承担。
- 栈封闭：只能通过局部变量才能访问对象。局部变量位于执行线程的栈中，其他线程无法访问这个栈。但需要确保被引用的对象不会逸出。
- ThreadLocal类：为每个使用该变量的线程都存有一份独立的副本。可以将`TheadLoacal<T>`看做`Map<Thread, T>`，其中保存了特定于该线程的值。

## 对象的组合

如果某个对象不是线程安全的，可以确保该对象只能由单个线程访问，或者通过一个锁来保护该对象的所有访问。**实例封闭**通过将一个对象封装到另一个对象中，来将其访问限制在该对象的方法上，从而更容易确保线程安全。

如果某个类中含有复合操作，那这个必须提供自己的加锁机制以保证这些复合操作都是原子操作。

## 基础构建模块


**同步容器类**包括`Vector`和`HashTable`。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个共有方法都进行同步。同步的封装器类是由`Collection.synchronizedXxx`等工厂方法创建的。

同步容器将所有对容器状态的访问都串行化，以实现线程安全，但其代价是吞吐量降低。

**并发容器**：用于改进同步容器的性能。如`ConcurrentMap`接口。

同步容器类在执行每个操作期间都持有一个锁。ConcurrentHashMap并不是将每个方法都在同一个锁上进行同步，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为**分段锁**。这种机制中，任意数量的读取进程可以并发访问Map，并且一定数量的写入线程可以并发修改Map。

