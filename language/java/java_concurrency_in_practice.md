# Java Concurrency in Practice

## 线程安全性

在并发编程中，由于不恰当的执行时序而出现的不正确的结果，称为**竞态条件**。

最常见的竞态条件类型就是“先检查后执行”，即通过一个可能失效的观测结果来决定下一步的动作。“先检查后执行”的一种常见情况就是延迟初始化（确保只被初始化一次）。

当在不变性条件中涉及多个变量时，各个变量之间并不是彼此独立的，当更新某一个变量时，需要在同一个原子操作中对其他变量同时进行更新。

Java提供了一种内置的锁机制来支持原子性：同步代码块。以关键字`synchronized`修饰。

同步代码块包括两部分：

1. 作为锁的对象引用
2. 作为由这个锁保护的代码块

某个线程请求一个由其他线程持有的锁时，会阻塞。而由于内置的锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，这个请求就会成功。

**重入**意味着锁的操作粒度是线程，而不是调用。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

## 对象的共享

同步除了可以确保原子性外，还有一个重要的方面：**内存可见性**。我们希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。
