# Thinking in Java

## 1. 一切皆对象

Java中一切都被视为对象，但操纵的标识符是对象的一个引用。

有5个地方可以存储数据：
1. 寄存器：最快的存储区，通常不能直接控制。
2. 堆栈：通过堆栈指针控制，一些数据如对象引用存放在堆栈中，但Java对象不存储其中
3. 堆：用于存放所有Java对象。编译器不需要知道存储的数据在堆中存活多长时间，更灵活。但用堆进行存储分配和清理需要更多时间。
4. 常量存储：常量值通常直接存在程序代码内部。
5. 非RAM存储：如流对象和持久化对象。

因为new把对象存储在堆中，所以用new创建一个对象，尤其是简单，小的变量不是很有效。

因此，Java不用new创建变量，而是创建一个不是引用的变量，直接存储值，置于堆栈中。

基本类型具有包装器类，可以在堆中创建一个非基本对象。

Java对象不具备和基本类型一样的生命周期，当用new创建一个Java对象时，它可以存活于作用域之外。

Java有垃圾回收器，监视用new创建的所有对象，一旦不被引用，就会释放其内存空间。

Java设计者希望程序员反过来使用自己的Internet域名，以保证类库是独一无二的。

当我们使用与编译器附在一起的Java标准类库时，可以不必写一长串反转域名。

2种情况未解决：
1. 只想为特定域分配单一存储空间，而不考虑到底创建了多少对象。
2. 希望某个方法不与其类的任何对象实例关联在一起，即没有创建对象，也能调用这个方法。

关键字static可以解决这两问题。

当声明一个事物是static时，就意味着这个域或方法不会与包含它的类的任何实例关联在一起：
- static字段对每个类只有一份存储空间
- static方法就是为了能在不创建对象的前提下调用它，如main()

赋值操作：
由于基本类型存储了实际的数值，故赋值就是将一个地方内容复制到另一个地方。
但对对象赋值时，真正操作的是对对象的引用。把对象传递给方法时，也是一样。

自动递增/递减：
- 前缀式：++操作符位于前面，先执行运算再生成值，即先加1再得到值
- 后缀式：++操作符位于后面，先生成值再执行运算，先得到值后加1

==和!=比较的是对象的引用，如果想比较两个对象实际内容是否相同，应使用equals()方法。

逻辑判断时，Java也支持短路。

C++中，sizeof()返回数据分配的字节数，为了移植，因为不同数据类型在不同机器上可能有不同大小。而Java没有sizeof()，因为所有数据类型在所有机器中的大小都是相同的。

## 5. 初始化与清理

编译器会暗自将该对象的引用作为第一个参数传递给该对象的方法。

当希望在方法内部获得对当前对象的引用，可以用this。

static方法可以看做没有this的方法，故在static方法内部不能调用非静态方法。

假如对象获得了一块特殊的内存区域，而由于垃圾回收器只释放由new分配的内存，不知道如何释放这块特殊内存，可以在类中定义finalize()方法。一旦垃圾回收器准备好释放对象所占有的存储空间，会首先调用其finalize()方法。

因为通常在堆上分配数据代价高昂，而Java的所有对象都在堆上分配。然而，Java的垃圾回收器能显著提高对象的创建速度。

垃圾回收器的识别算法：
1. 引用计数：每个对象都有一个引用计数器，当引用计数为0时，就释放占用的空间。但无法处理对象间的循环引用。
2. 根搜索：对任何活的对象，一定追溯到存活在堆栈或静态存储区中的引用。从堆栈和静态存储区开始，遍历所有引用，就能找到所有活着的对象。

垃圾回收器的回收算法：
1. 停止-复制：先暂停程序，再将所有存活的对象从当前堆复制到另一个堆。但需要两个堆，复制过程有时也很低效。
2. 标记-清扫：当找到一个存活对象，给对象一个标记。全部标记完成后，清理没有标记的对象。重新整理剩下的对象。
3. 自适应：当所有对象都很稳定，只会产生少量垃圾，切换到标记-清扫方式；当堆空间中出现很多碎片，切换到停止-复制方式。


类中初始化顺序是先静态对象，而后非静态对象。

## 6. 访问权限控制

每个编译单元中只能有一个public类。public类名必须与文件名匹配，包括大小写。

当编译一个.java文件时，文件中每个类都会有一个输出文件，该输出文件名称与类名相同，后缀为.class。可以将一组.class文件打包并压缩为Java文档文件(JAR)。

Java解释器运行过程：
- 找到环境变量CLASSPATH，其中包含多个目录用于查找.class文件的根目录。
- 从根目录开始，解释器获取包的名称并将每个句点替换为反斜杠，以产生一个路径名
- 解释器就在这些目录中查找相关的.class文件

访问权限修饰符：

- 如果不提供任何访问权限修饰符，则为包访问权限，即当前包所有其他类都有访问权限，而包之外的类没有。
- public：均可用
- private：除了该类外，其他任何类都无法访问
- protected：也提供包访问权限，同时访问权限会赋予派生类


对于类的访问权限，只有两种选择：包访问权限或public。

相同目录下所有不具有明确package声明的文件，都被视为该目录下默认包的一部分。

Java会自动在导出类的构造器中插入对基类构造器的调用。

final通常用于告知一块数据是恒定不变的。

对于基本类型，final使数值恒定不变。而对于对象引用，final使引用恒定不变，但对象自身可以被修改。

final方法一方面可以把方法锁定，一方面可以提高效率，即对该的所有调用会转为内嵌调用。
private方法默认为final方法。

final类表示该类不打算被继承。

## 8. 多态

**绑定**：将一个方法调用同一个方法主体关联起来。
- 前期绑定：在程序执行前进行绑定
- 后期绑定：在运行时根据对象类型进行绑定，也叫运行时绑定

Java中除了static和final方法之外，其他所有方法都是后期绑定。

复杂对象调用构造器遵循的顺序：
1. 调用基类构造器
2. 按声明顺序调用成员的初始化方法
3. 调用导出类构造器主体

## 9. 接口

抽象方法：仅有声明而没有方法体。
包含抽象方法的类叫抽象类。需用abstract来限定这个类。
如果想从抽象类继承，就必须提供为其所有抽象方法提供方法定义。否则导出类也是抽象类。

接口interface产生一个完全抽象的类，没有任何具体实现。
接口可以包含域，但这些域隐式地是static和final的。

## 10. 内部类

pass

## 11. 持有对象

Java容器类库可以划分为两类：
1. Collection：元素序列，元素会服从一些规则，如不能有重复元素，排队规则确定顺序等。
2. Map：一组成对的键值对对象。

List有两种类型：
1. ArrayList：随机访问快，插入和删除元素较慢
2. LinkedList：插入删除元素快，随机访问慢

对容器元素操作时，通常需要对容器的确切类型编程。可以用迭代器来统一代码。
迭代器可以将遍历序列的操作与序列底层的结构分离，即统一了对容器的访问方式。

Set：HashSet, TreeSet, LinkedHashSet.

foreach可以应用于任何Collection对象，以及实现了Iterable接口的类。

## 12. 通过异常处理错误

抛出异常：在当前环境中无法获得必要的信息来解决问题，因此从当前环境中挑出，把问题交给上一级环境。

抛出异常后，将用new在堆上创建异常对象，当前执行路径被终止，并且从当前环境中弹出对异常对象的引用。此时异常处理机制接管程序，寻找异常处理程序。

Throwable类用来表示任何可以作为异常被抛出的类。可分为两种类型：
1. Error：表示编译时和系统错误（一般不用关心）
2. Exception：在Java类库，用户方法以及运行时故障都可能抛出，分为编译时异常和运行时异常。

Exception是与编程有关的所有异常类的基类。其基类是Throwable。
printStackTrace() 能打印Throwable和其调用栈轨迹，调用栈显示了把你带到异常抛出点的方法调用序列。

**运行时异常**会自动被Java虚拟机抛出，这些异常都是从RuntimeException类继承而来，也被称为不受检查异常。所以也不必在异常说明中把它们列出来。例如NullPointerException。

如果RuntimeException没有被捕获而直达main()，那么程序退出前将调用异常的printStackTrace()方法。

当覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常。这使得基类使用的代码能应用到派生类对象。但这种限制对构造器不起作用，即构造器可以不理会基类构造器所抛出的异常。

**被检查的异常**会强制你在可能还没准备好处理错误的时候被迫加上catch语句。
实际上，当在一个方法中调用其他方法时，不知道怎么处理一个异常，但也不想把它吞了，可以直接把被检查的异常包装进RuntimeException里，转换为不检查的异常。如下
```
catch (xxxCheckedException e) {
    throw new RuntimeException(e);
}
```

## 13. 字符串

String对象是不可变的。每一个看起来会修改String值的方法都是创建了一个新的String对象。

不变性带来的效率问题，可以用StringBuilder提高效率。

## 14. 类型信息

有两种方式让我们在运行时识别对象和类的信息：
1. RTTI
2. 反射机制

Java使用Class对象来执行其RTTI。每个类都有一个Class对象。

所有的类都是在对其第一次使用时，动态加载到JVM中。当程序创建第一个对类的静态成员的引用时，就会加载这个类（构造器是类的静态方法）。

已知的RTTI形式：
- 传统的类型转换
- 代表对象的类型的Class对象
- instance of，告诉对象是不是某个特定类型的实例

RTTI需要类型在编译时已知，才能识别它。但可能遇到一些情况，在编译时无法获知这个对象所属的类。 -> 反射机制

Class类与java.lang.reflect类库一起对反射进行了支持。

对RTTI来说，编译器在编译时打开和检查.class文件。
对反射机制来说，.class文件在编译时不可获取，所以是在运行时打开和检查.class文件。

## 15. 泛型

使用接口虽然具有一定泛化性，但仍有较大约束。泛型使代码应用于某种不具体的类型，而不是具体的接口或类。

是否拥有泛型方法与其所在类是否是泛型没有关系。

定义泛型方法，只需将泛型参数列表置于返回值之前。

在泛型代码内部，无法或得任何与有关泛型参数类型的信息。

## 21. 并发

在单核上运行并发程序开销更大，因为增加了所谓上下文切换的代价。
但如果有任务出现阻塞，并发能够使程序中其他任务继续执行。
