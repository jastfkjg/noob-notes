# Understanding the JVM

## 1. Java内存区域与内存溢出异常

### 1.1 运行时数据区域

Java虚拟机在执行程序时会把它所管理的内存划分为不同数据区域：

1. 程序计数器：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。这类内存称为线程私有的内存。
2. Java虚拟机栈：也是线程私有的。每个方法被执行时，虚拟机会同步创建一个栈帧，用于储存局部变量表，操作数栈，方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
3. 本地方法栈：虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用本地方法服务。
4. Java堆：被所有线程共享，存放对象实例。
5. 方法区：所有线程共享，用于存储已加载的类型信息，常量，静态变量等数据。
6. 运行时常量池：（方法区的一部分），Class文件有一项信息是常量池表，用于存放编译期生成的字面量和符号引用，这部分会在类加载后存放到方法区的运行时常量池中。
7. 直接内存：不属于虚拟机运行时数据区的一部分，但也被频繁使用。

### 1.2 虚拟机对象

当虚拟机遇到new指令时：

- 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查符号引用对应的类是否已被加载，解析和初始化
- 如果没有，则执行类加载过程
- 加载完成后，对象所需的内存大小便可完全确定，即把一块确定大小内存块从Java堆中划分出来
- 将必要信息存放在对象的对象头中
- 对象创建完成，但所有字段都是默认的零值
- 通常new指令之后，会接着执行init方法

对象在内存中的存储可分为三个部分：对象头，实例数据，对齐填充。

Java通过栈上的reference数据来操作堆上的具体对象。但对象的具体访问方式也是由虚拟机实现决定。通常分为两种：

- 句柄：会在Java堆中划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，句柄中包含对象具体的地址信息
- 直接指针

### 1.3 OOM异常

- Java堆溢出：异常堆栈信息java.lang.OutOfMemoryError会跟随进一步提示：Java heap space。通常分为 内存泄漏(Memory Leak) 和 内存溢出(Memory Overflow)。
  - 内存泄漏：通过工具查看泄漏对象到GC Root的引用链，从而定位泄漏代码
  - 内存溢出：即对象确实都是必须存活的，检查虚拟机的堆参数设置(-Xmx, -Xms)
- 虚拟机栈/本地方法栈 溢出：通常为两种异常：
  - StackOverFlowError: 线程请求的栈深度大于虚拟机允许的最大深度，栈帧太大或虚拟机栈容量太小都可能导致该异常
  - OutOfMemoryError: 当扩展栈容量无法申请到足够内存时
- 方法区/运行时常量池溢出：(PermGen space)
- 直接内存溢出

## 2. 垃圾收集器与内存分配策略

垃圾收集需完成的3件事：

1. 哪些内存需回收，即判断对象是否存活
2. 什么时候回收
3. 如何回收

### 2.1 对象是否存活

- 引用计数算法：难以解决对象间相互引用的问题。
- 可达性分析算法：通过GC Roots的根对象作为起始节点集，根据引用关系向下搜索，搜索所走过的路径称为引用链。如果某个对象到GC Roots间没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可能再被使用的。

### 2.2 垃圾收集算法

垃圾收集算法可分为引用计数式和追踪式。主要介绍追踪式。

**分代收集理论**：

1. 弱分代假说：绝大多数对象都是朝生夕灭的。
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

这两分代假说奠定了常用垃圾收集器的设计原则：收集器应该将Java堆划分出不同的区域。这样垃圾收集器也能每次只回收某部分的区域。
一般至少会把Java堆划分为新生代和老年代两个区域。

然而对象不是孤立的，对象之间会存在跨代引用。如进行局限于新生代中的收集，但新生代中的对象可能被老年代所引用，从而不得不额外遍历老年代。为了解决这个问题，添加了第三条经验法则：

3. 跨代引用假说：跨代引用相对于同代引用来说只占少数。

这样，我们可以将老年代分为若干小块，标识哪一块存在跨代引用，从而只需扫描包含跨代引用的小块。

GC:
  - Partial GC:
    - Minor/Young GC
    - Major/Old GC
    - Mixed GC
  - Full GC

**标记-清除算法**

是最基础的收集算法。即首先标记出所有需要回收的对象，随后回收所有被标记的对象。

有两个缺点：

1. 执行效率随对象数量增长而降低
2. 内存空间的碎片化问题

**标记-复制算法**

将内存按容量分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。

常用于回收新生代。

**标记-整理算法**

针对老年代的回收。

标记过程和标记-清理算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后清理掉边界以外的内存。

但这种对象移动操作不仅是一种极为负重的操作，而且必须全程暂停用户应用程序。

但如果不考虑移动和整理存活对象的话，空间碎片化问题就只能依赖内存分配器和内存访问器来解决。

是否移动对象都存在弊端：移动则内存回收时会更复杂，不移动则内存分配时会更复杂。

### 2.3 HotSpot算法细节实现

根节点枚举：所有收集器在根节点枚举这一步都必须暂停用户线程，因为枚举期间需保证执行子系统中对象引用不会发生变化。

在OopMap的协助下，HotSpot可以快速完成GC Roots枚举。但如果为每一条指令都生成对应的OopMap，会需要大量的额外存储空间。
实际上，HotSpot只是在特定位置记录了这些信息，这些位置被称为**安全点**。程序必须强制执行到达安全点后才能暂停。

如何在垃圾收集发生时让所有线程都跑到最近的安全点：

- 抢先式中断
- 主动式中断

有时用户线程处于Sleep状态或是Blocked状态，无法响应虚拟机的中断请求，这时需要引入安全区域来解决。
**安全区域**：确保在某一段代码中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。

跨代引用解决方案：

- 记忆集：用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。
- 写屏障：解决记忆集维护问题，需要找到一个在机器码层面的手段，把维护记忆集的动作放到每一个赋值操作之中。

### 2.4 内存分配

- 大多数情况下，对象在新生代中的Eden区中分配。当Eden区没有足够空间时，会发起一次Minor GC。
- 大对象直接进入老年代。为了避免对象在Eden区和两个Survivor区之间来回复制。
- 长期存活的对象进入老年代。对象年龄计数器，存储在对象头中。

## 3. 虚拟机性能监控

JDK的bin目录下，除了java.exe,javac.exe外，还有其他各种小工具：

- jps：虚拟机进程状况工具：列出正在运行的虚拟机进程，并显示虚拟机执行主类及本地虚拟机唯一ID。
- jstat：虚拟机统计信息监控。
- jinfo：实时查看和调整虚拟机各项参数。
- jmap：用于生成堆转储快照。
- jhat：与jmap搭配使用，用于分析jmap生成的堆转储快照。
- jstack：用于生成虚拟机当前时刻的线程快照，即每一条线程正在执行的方法堆栈集合，通常用于定位线程长时间停顿的原因。
- jconsole：基于JMX的可视化监视，管理工具。

HotSpot虚拟机插件及工具：

- HSIDS：虚拟机即时编译代码的反汇编插件，用于把即时编译器动态生成的本地代码还原为汇编代码输出。

