# Understanding the JVM

## 1. Java内存区域与内存溢出异常

### 1.1 运行时数据区域

Java虚拟机在执行程序时会把它所管理的内存划分为不同数据区域：

1. 程序计数器：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。这类内存称为线程私有的内存。
2. Java虚拟机栈：也是线程私有的。每个方法被执行时，虚拟机会同步创建一个栈帧，用于储存局部变量表，操作数栈，方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
3. 本地方法栈：虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用本地方法服务。
4. Java堆：被所有线程共享，存放对象实例。
5. 方法区：所有线程共享，用于存储已加载的类型信息，常量，静态变量等数据。
6. 运行时常量池：（方法区的一部分），Class文件有一项信息是常量池表，用于存放编译期生成的字面量和符号引用，这部分会在类加载后存放到方法区的运行时常量池中。
7. 直接内存：不属于虚拟机运行时数据区的一部分，但也被频繁使用。

### 1.2 虚拟机对象

当虚拟机遇到new指令时：

- 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查符号引用对应的类是否已被加载，解析和初始化
- 如果没有，则执行类加载过程
- 加载完成后，对象所需的内存大小便可完全确定，即把一块确定大小内存块从Java堆中划分出来
- 将必要信息存放在对象的对象头中
- 对象创建完成，但所有字段都是默认的零值
- 通常new指令之后，会接着执行init方法

对象在内存中的存储可分为三个部分：对象头，实例数据，对齐填充。

Java通过栈上的reference数据来操作堆上的具体对象。但对象的具体访问方式也是由虚拟机实现决定。通常分为两种：

- 句柄：会在Java堆中划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，句柄中包含对象具体的地址信息
- 直接指针

### 1.3 OOM异常

- Java堆溢出：异常堆栈信息java.lang.OutOfMemoryError会跟随进一步提示：Java heap space。通常分为 内存泄漏(Memory Leak) 和 内存溢出(Memory Overflow)。
  - 内存泄漏：通过工具查看泄漏对象到GC Root的引用链，从而定位泄漏代码
  - 内存溢出：即对象确实都是必须存活的，检查虚拟机的堆参数设置(-Xmx, -Xms)
- 虚拟机栈/本地方法栈 溢出：通常为两种异常：
  - StackOverFlowError: 线程请求的栈深度大于虚拟机允许的最大深度，栈帧太大或虚拟机栈容量太小都可能导致该异常
  - OutOfMemoryError: 当扩展栈容量无法申请到足够内存时
- 方法区/运行时常量池溢出：(PermGen space)
- 直接内存溢出

## 2. 垃圾收集器与内存分配策略

垃圾收集需完成的3件事：

1. 哪些内存需回收，即判断对象是否存活
2. 什么时候回收
3. 如何回收

### 2.1 对象是否存活



