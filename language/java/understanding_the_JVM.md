# Understanding the JVM

## 1. Java内存区域与内存溢出异常

### 1.1 运行时数据区域

Java虚拟机在执行程序时会把它所管理的内存划分为不同数据区域：

1. 程序计数器：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。这类内存称为线程私有的内存。
2. Java虚拟机栈：也是线程私有的。每个方法被执行时，虚拟机会同步创建一个栈帧，用于储存局部变量表，操作数栈，方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
3. 本地方法栈：虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用本地方法服务。
4. Java堆：被所有线程共享，存放对象实例。
5. 方法区：所有线程共享，用于存储已加载的类型信息，常量，静态变量等数据。
6. 运行时常量池：（方法区的一部分），Class文件有一项信息是常量池表，用于存放编译期生成的字面量和符号引用，这部分会在类加载后存放到方法区的运行时常量池中。
7. 直接内存：不属于虚拟机运行时数据区的一部分，但也被频繁使用。

### 1.2 虚拟机对象

当虚拟机遇到new指令时：

- 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查符号引用对应的类是否已被加载，解析和初始化
- 如果没有，则执行类加载过程
- 加载完成后，对象所需的内存大小便可完全确定，即把一块确定大小内存块从Java堆中划分出来
- 将必要信息存放在对象的对象头中
- 对象创建完成，但所有字段都是默认的零值
- 通常new指令之后，会接着执行init方法

对象在内存中的存储可分为三个部分：对象头，实例数据，对齐填充。

Java通过栈上的reference数据来操作堆上的具体对象。但对象的具体访问方式也是由虚拟机实现决定。通常分为两种：

- 句柄：会在Java堆中划分出一块内存作为句柄池，reference存储的就是对象的句柄地址，句柄中包含对象具体的地址信息
- 直接指针

### 1.3 OOM异常

- Java堆溢出：异常堆栈信息java.lang.OutOfMemoryError会跟随进一步提示：Java heap space。通常分为 内存泄漏(Memory Leak) 和 内存溢出(Memory Overflow)。
  - 内存泄漏：通过工具查看泄漏对象到GC Root的引用链，从而定位泄漏代码
  - 内存溢出：即对象确实都是必须存活的，检查虚拟机的堆参数设置(-Xmx, -Xms)
- 虚拟机栈/本地方法栈 溢出：通常为两种异常：
  - StackOverFlowError: 线程请求的栈深度大于虚拟机允许的最大深度，栈帧太大或虚拟机栈容量太小都可能导致该异常
  - OutOfMemoryError: 当扩展栈容量无法申请到足够内存时
- 方法区/运行时常量池溢出：(PermGen space)
- 直接内存溢出

## 2. 垃圾收集器与内存分配策略

垃圾收集需完成的3件事：

1. 哪些内存需回收，即判断对象是否存活
2. 什么时候回收
3. 如何回收

### 2.1 对象是否存活

- 引用计数算法：难以解决对象间相互引用的问题。
- 可达性分析算法：通过GC Roots的根对象作为起始节点集，根据引用关系向下搜索，搜索所走过的路径称为引用链。如果某个对象到GC Roots间没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可能再被使用的。

### 2.2 垃圾收集算法

垃圾收集算法可分为引用计数式和追踪式。主要介绍追踪式。

**分代收集理论**：

1. 弱分代假说：绝大多数对象都是朝生夕灭的。
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

这两分代假说奠定了常用垃圾收集器的设计原则：收集器应该将Java堆划分出不同的区域。这样垃圾收集器也能每次只回收某部分的区域。
一般至少会把Java堆划分为新生代和老年代两个区域。

然而对象不是孤立的，对象之间会存在跨代引用。如进行局限于新生代中的收集，但新生代中的对象可能被老年代所引用，从而不得不额外遍历老年代。为了解决这个问题，添加了第三条经验法则：

3. 跨代引用假说：跨代引用相对于同代引用来说只占少数。

这样，我们可以将老年代分为若干小块，标识哪一块存在跨代引用，从而只需扫描包含跨代引用的小块。

GC:
  - Partial GC:
    - Minor/Young GC
    - Major/Old GC
    - Mixed GC
  - Full GC

**标记-清除算法**

是最基础的收集算法。即首先标记出所有需要回收的对象，随后回收所有被标记的对象。

有两个缺点：

1. 执行效率随对象数量增长而降低
2. 内存空间的碎片化问题

**标记-复制算法**

将内存按容量分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用的内存空间一次清理掉。

常用于回收新生代。

**标记-整理算法**

针对老年代的回收。

标记过程和标记-清理算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后清理掉边界以外的内存。

但这种对象移动操作不仅是一种极为负重的操作，而且必须全程暂停用户应用程序。

但如果不考虑移动和整理存活对象的话，空间碎片化问题就只能依赖内存分配器和内存访问器来解决。

是否移动对象都存在弊端：移动则内存回收时会更复杂，不移动则内存分配时会更复杂。

### 2.3 HotSpot算法细节实现

根节点枚举：所有收集器在根节点枚举这一步都必须暂停用户线程，因为枚举期间需保证执行子系统中对象引用不会发生变化。

在OopMap的协助下，HotSpot可以快速完成GC Roots枚举。但如果为每一条指令都生成对应的OopMap，会需要大量的额外存储空间。
实际上，HotSpot只是在特定位置记录了这些信息，这些位置被称为**安全点**。程序必须强制执行到达安全点后才能暂停。

如何在垃圾收集发生时让所有线程都跑到最近的安全点：

- 抢先式中断
- 主动式中断

有时用户线程处于Sleep状态或是Blocked状态，无法响应虚拟机的中断请求，这时需要引入安全区域来解决。
**安全区域**：确保在某一段代码中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。

跨代引用解决方案：

- 记忆集：用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。
- 写屏障：解决记忆集维护问题，需要找到一个在机器码层面的手段，把维护记忆集的动作放到每一个赋值操作之中。

### 2.4 内存分配

- 大多数情况下，对象在新生代中的Eden区中分配。当Eden区没有足够空间时，会发起一次Minor GC。
- 大对象直接进入老年代。为了避免对象在Eden区和两个Survivor区之间来回复制。
- 长期存活的对象进入老年代。对象年龄计数器，存储在对象头中。

## 3. 虚拟机性能监控

JDK的bin目录下，除了java.exe,javac.exe外，还有其他各种小工具：

- jps：虚拟机进程状况工具：列出正在运行的虚拟机进程，并显示虚拟机执行主类及本地虚拟机唯一ID。
- jstat：虚拟机统计信息监控。
- jinfo：实时查看和调整虚拟机各项参数。
- jmap：用于生成堆转储快照。
- jhat：与jmap搭配使用，用于分析jmap生成的堆转储快照。
- jstack：用于生成虚拟机当前时刻的线程快照，即每一条线程正在执行的方法堆栈集合，通常用于定位线程长时间停顿的原因。
- jconsole：基于JMX的可视化监视，管理工具。

HotSpot虚拟机插件及工具：

- HSIDS：虚拟机即时编译代码的反汇编插件，用于把即时编译器动态生成的本地代码还原为汇编代码输出。

## 4. 类文件结构

计算机只认识0和1，因此程序需要被编译器翻译成由0和1构成的二进制格式才能被计算机执行。

但一些建立在虚拟机之上的程序语言，可以选择与操作系统和机器指令集无关的，平台中立的格式作为程序编译后的存储格式。

Java虚拟机不与任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联。而丝毫不关心Class文件的来源是什么语言。

### 4.1 Class类文件结构

任何一个Class文件都对应着唯一一个类或接口的定义信息。

Class文件时一组以字节为基础单位的二进制流。

每个Class文件的头4个字节被称为魔数，用于确定这个文件是否为一个能被虚拟机接收的Class文件。Class文件的魔数值为`0xCAFEBABE`。紧接着魔数的4个字节为Class文件的版本号。

其他还包括：

- 常量池
- 访问标志
- 类索引，父类索引，接口索引集合
- 字段表
- 方法表
- 属性表

### 4.2 字节码指令

Java虚拟机的指令由一个字节长度的，代表某种特定操作含义的数字（操作码）及随后的零或多个参数（操作数）构成。

由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大部分指令都不包含操作数，指令参数都存放在操作数栈中。

- 加载和存储指令：将数据在栈帧中的局部变量表和操作数栈之间来回传输。如`load,store,push`等
- 运算指令：`add, sub, mul, div, rem, neg, shl, or, and, xor, inc, cmp`
- 类型转换指令：`i2b, i2c, i2s, l2i, d2f`等
- 对象创建和访问指令：`new, newarray, getfield, instanceof`等
- 控制转移指令
- 方法调用和返回指令
- 异常处理指令
- 同步指令

## 5. 虚拟机加载机制

一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期将会经历：
**加载，验证，准备，解析，初始化，使用，卸载** 七个阶段。

### 5.1 类加载的过程

类加载的过程包括加载，验证，准备，解析和初始化。

**加载**：加载阶段，虚拟机要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

注意这三点要求并不是特别具体，如第一点，并没有指定二进制字节流必须得从某个Class文件中获取。这也提供了多种可能性，如从ZIP压缩包，JAR，WAR中读取；从网络中获取；运行时动态生成等。

数组类不同于非数据类型，其本身不通过类加载器创建，而是由Java虚拟机直接在内存中动态构造出来的。但数据类的元素类型最终还是要靠类加载器来完成加载。

**验证**：是连接阶段的第一步，目的是确保Class文件中的字节流包含的信息符合《Java虚拟机规范》的全部约束条件。主要分为下面四个阶段的检验动作：

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

**准备**：是正式为类中定义的变量分配内存并设置类变量初始值的阶段。这里的初始值通常情况下是指数据类型的零值。

**解析**：虚拟机将常量池内的符号引用替换为直接引用的过程。
  - 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量。
  - 直接引用：是直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

**初始化**：是类加载过程的最后一个步骤。在准备阶段时，变量已经赋予过一次初始零值，而在初始化阶段，则会执行类构造器`<clinit>()`方法。

`<clinit>()`方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。

### 5.2 类加载器

虚拟机设计团队有意让加载阶段的第一步：“通过一个类的全限定名来获取描述该类的二进制字节流”放到虚拟机外部去实现，这样可以方便应用程序自己决定如何获取所需的类。而实现这个动作的代码被称为**类加载器**。

比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。

从虚拟机角度来看，只存在两种不同的类加载器：

1. 启动类加载器：是虚拟机自身的一部分
2. 其他所有类加载器：独立存在于虚拟机外部，并且全部都继承自抽象类`java.lang.ClassLoader`

## 6. 虚拟机字节码执行引擎

虚拟机以方法作为最基本的执行单元，**栈帧**则是用于支持虚拟机进行方法调用和执行背后的数据结构。每一个栈帧都包括局部变量表，操作数栈，动态连接，方法返回地址等信息。

- **局部变量表**：用于存放方法参数和方法内部定义的局部变量。
- **操作数栈**：LIFO栈。当一个方法刚开始执行时，这个方法操作数栈是空的，执行过程中则会有各种字节码指令往操作数栈中写入和提取内容。
- **动态连接**
- **方法返回地址**


