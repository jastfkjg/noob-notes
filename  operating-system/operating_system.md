# 操作系统

参考 [哈工大操作系统基础](csapp.mdhttps://mooc.study.163.com/course/1000002004?tid=2403042008#/info)

开机执行顺序：
BIOS -> bootsect（引导扇区） -> setup -> head -> main

以上主要两个工作：
1. 将操作系统读入内存
2. 一系列初始化（内存，设备，cpu，中断等）

POSIX (Portable Operating System Interface of Unix) 是操作系统接口的一个标准族。

**中断**：在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。中断一般分为三类：

1. 由计算机硬件异常或故障引起的中断，称为内部异常中断
2. 由程序中执行了引起中断的指令而造成的中断，称为软中断
3. 由外部设备请求引起的中断，称为外部中断

**系统调用**： 程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，如读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。

一种硬件设计可以将内核程序和用户程序进行隔离，以防止应用程序直接访问操作系统内部导致安全问题。分为内核态和用户态。用户态不能访问内核数据，内核态可以访问任何数据。硬件也提供来进入内核的方法，即中断，或称系统调用。

当进程发出系统调用之后，它所处的运行状态就会由用户态变成核心态。

系统调用的核心：
1. 用户程序包含一段包含int指令（int 0x80）的代码
2. 操作系统写中断处理，获取对应系统调用号
3. 操作系统根据系统调用号查idt表，执行相应代码


## 并发

IO指令耗时远高于计算指令，这导致按序执行CPU利用率低。因此，采用多个程序交替执行的方式，称为**并发**。

**分时系统**：每个程序运行一段时间之后，都主动让出 CPU 资源，这样每个程序在一段时间内都有机会运行一小段时间。

在分时系统中，如果某个程序出现了错误，导致了死循环，不仅仅是这个程序会出错，整个系统都会死机。

**多任务系统**： 操作系统从最底层接管了所有硬件资源。所有的应用程序在操作系统之上以 进程（Process） 的方式运行，每个进程都有自己独立的地址空间，相互隔离。CPU 由操作系统统一进行分配。每个进程都有机会得到 CPU，同时在操作系统控制之下，如果一个进程运行超过了一定时间，就会被暂停掉，失去 CPU 资源。这样就避免了一个程序的错误导致整个系统死机。

**进程**：运行中的程序。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。

> 多进程的组织：
- PCB (Process Control Block)：记录进程信息的数据结构
- 状态图：就绪态，运行态，阻塞态
- 队列

例：当某一进程启动IO后，将切换至其他进程。当前进程状态从运行态转为阻塞态，并被放入阻塞队列。操作系统根据某一进程调度算法从就绪队列中选出下一进程。保存当前进程信息到PCB，加载下一进程PCB。

> 多进程之间的影响？

多个进程可能会共同访问某一内存地址 -> 需限制对内存的读写 -> 将不同进程地址空间进行分离（地址映射表）

**临界资源**：但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。

对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。

**线程**：在进程之间进行切换时，能不能只切换指令，不切换资源（如地址映射表等）？线程通过共享资源来避免进程切换所需的代价。

不同的线程需要不同的TCB(Thread Control Block)和栈。

> 用户级线程（协程）

yield，threadCreate都是用户程序，线程的切换需要用户自己主动调用yield函数。

缺点：
- 内核看不到多个线程
- 当其中一个线程阻塞时，内核可能会切到其他进程
  
```
threadCreate(A):  // A为线程初始地址
    1. TCB *tcb = malloc()  
    2. *stack = malloc()  // 为TCB和栈分配空间
    3. *stack = A         // 将线程初始地址放入栈中
    4. tab.esp = stack    // TCB与栈关联
```

```
yield:
    1. 下一地址压栈
    2. 当前栈存入TCB中
    3. 调度，获得下一线程
    4. 从下一TCB取栈
    5. 弹栈获取地址
```

> 核心级线程

- threadCreate是系统调用
- 会进入内核，即内核知道有多个线程的存在
- 调度点由系统决定（无法调用yield）
- 相比于用户级线程，可以真正利用多核
  
核心级线程相比用户级线程，需要由多个栈转为多套栈。其中一套栈可以分为：
1. 用户栈
2. 内核栈

> 常见CPU调度算法：
- FIFO
- SJF（短作业优先）：缩短平均周转时间
- 优先级调度：不同任务对相应时间和周转时间关注程度不同
- Round Robin：按时间片轮转调度：保证相应时间
- 多级队列
- 多级反馈队列

## 进程同步

**信号量**：对该变量的访问和修改，可以让多个进程有序推进。

当多个进程同时修改信号量时，可能导致信号量出错。

**临界区**：一次只允许一个进程进入的该进程的那一段代码。即这段代码只能一个进程进入。

读写信号量的代码一定是临界区。

临界区保护的方法：（基于软件算法）
- 轮转法：某一进程卡住时会导致其他进程无法进入
- 标记法：可能导致两进程同时等待另一进程进入
- 轮转+标记法

临界区保护的方法：（基于硬件）
- 阻止调度 -> 如阻止时钟中断 -> 关中断cli()/sti() （不适用于多核）
- 指令不被打断 -> 硬件原子指令

进程同步的基本思想：用临界区保护信号量，用信号量实现进程同步。

**死锁**：多个进程互相等待对方所持有的资源

死锁的四个必要条件：
1. 互斥使用：资源的特性
2. 不可抢占：资源只能被进程自愿放弃
3. 请求和保持：进程先是占有一些资源，又申请别的资源
4. 循环等待：资源分配图中存在环路

死锁的处理方法：
1. 死锁预防：破坏死锁的四个必要条件
   - 一次性申请所有资源
   - 资源按顺序申请
2. 死锁避免：资源请求时进行判断，会造成死锁则拒绝
   - 请求时，先假装分配，再调用银行家算法判断是否造成死锁
3. 死锁检测+恢复：某些进程回滚，让出资源
   - 定时检测，回滚
4. 死锁忽略：死锁出现为小概率事件，死锁忽略代价最小

## 内存管理

重定位：修改程序中的地址。分为：
- 编译时重定位：只能放在内存固定位置
- 载入时重定位：一旦载入内存后就不能移动
- 运行时重定位：每执行一条指令都要从逻辑地址转为物理地址（地址翻译）

程序分段分别放入内存，各个段的基址存于进程段表（LDT）中，包括段号，基址和长度。

内存会分为固定大小的页，因此程序的一个段会被打散成多个页。

为了提高空间利用率，页通常较小，导致页表较大。如果用到的逻辑页才有页表项，会导致页号不连续，查找困难。此时可以考虑采用多级页表。


也可以使用快表（TLB）：其存储最近使用的页号及其对应的页框号。（依赖程序的局部性）
如果TLB命中失败，再去查多级页表。

虚拟内存：
- 用户程序段与虚拟内存关联
- 虚拟内存中的区被打散成页，映射到物理内存


内存换入/换出：
- 换入：
  - MMU发现缺页 -> 中断 -> 页错误处理程序 -> 申请空闲页 -> 从磁盘读入数据到该页 -> 加入页表
- 换出：
  - 淘汰算法（即淘汰哪一个页？）
    - FIFO
    - LRU：
      1. 每个页维护一个时间戳 （代价大）
      2. 维护一个页码的栈 （代价大）
    - 时钟算法（LRU的近似实现）
      - 循环队列，维护一个引用位，扫描时是1时清0，继续扫描，是0时淘汰；访问页时置为1
      - 当很少出现缺页时，可能时钟引用位大部分为1，算法退化为FIFO。可以考虑定时清0


## 外设与文件系统

1. CPU向设备控制器中的寄存器读写数据
2. 通过文件形成统一的文件视图
3. 控制器完成工作，向CPU发中断信号，进行中断处理


- 最直接使用磁盘：告知柱面，扇区，磁头，缓存位置。
- 通过盘块号读写磁盘：磁盘驱动根据盘块号计算扇区，柱面，磁头。（一层抽象）
- 多进程通过队列请求磁盘 （二层抽象）
- 通过文件读写磁盘 （三层抽象）
- 文件系统 （四层抽象）

磁盘调度：
- FCFS
- SSTF(Shortest Seek Time First)
- SSTF + 中途不回折 （使得每个请求都有处理机会）
- 电梯算法：SCAN + 直接滑到另一端

通常通过多级索引实现文件系统，盘块号记录在inode中。


- 获取字符位置
- 字符位置除以块大小得到段号
- 根据文件inode中映射表和段号查磁盘盘块号
- 向磁盘发出请求，放入电梯队列


目标树：
根据目录得到文件inode。inode包含一些文件信息。

每个目录下存储文件名及其inode地址。